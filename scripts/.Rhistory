text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels = powers,
cex = 1,
col = "red")
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab = "Soft Threshold (power)",
ylab = "Scale Free Topology Model Fit, signed R^2",
type = "n",
main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels = powers,
cex = 1,
col = "red")
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab = "Soft Threshold (power)",
ylab = "Scale Free Topology Model Fit, signed R^2",
type = "n",
main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels = powers,
cex = 1,
col = "red")
abline(h = 0.90, col = "red")
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab = "Soft Threshold (power)",
ylab = "Scale Free Topology Model Fit, signed R^2",
type = "n",
main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels = powers,
cex = 1,
col = "red")
abline(h = 0.90, col = "red")
plot(sft$fitIndices[,1],sft$fitIndices[,5],
xlab = "Soft Threshold (power)",
ylab = "Mean Connectivity",
type = "n",
main = paste("Mean connectivity"))
plot(sft$fitIndices[,1],sft$fitIndices[,5],
xlab = "Soft Threshold (power)",
ylab = "Mean Connectivity",
type = "n",
main = paste("Mean connectivity"))
# Add sft values
text(sft$fitIndices[,1], sft$fitIndices[,5],
labels = powers,
cex = 1,
col = "red")
softPower <- 14
softPower <- 20
adjacency <- adjacency(CrabExpr0, power = softPower)
# Minimize noise and spurious associations by transforming adjacency into TOM
TOM <- TOMsimilarity(adjacency)
#Calculate dissimilarity matrix
dissTOM <- 1 - TOM
# Create hierarchical clustering object
geneTree <- hclust(as.dist(dissTOM), method = "average")
# Plot initial dendrogram. Dissimilarity is based on topological overlap
plot(geneTree, xlab = "", sub = "",
main = "Gene clustering on TOM-based dissimilarity",
labels = FALSE,
hang = 0.04)
softPower <- 20
adjacency <- adjacency(CrabExpr0, power = softPower)
# Minimize noise and spurious associations by transforming adjacency into TOM
TOM <- TOMsimilarity(adjacency)
#Calculate dissimilarity matrix
dissTOM <- 1 - TOM
# Clustering using TOM
# Create hierarchical clustering object
geneTree <- hclust(as.dist(dissTOM), method = "average")
# Plot initial dendrogram. Dissimilarity is based on topological overlap
plot(geneTree, xlab = "", sub = "",
main = "Gene clustering on TOM-based dissimilarity",
labels = FALSE,
hang = 0.04)
# Set minimum module size, AKA num of genes that need to be in a module. Here, using WGCNA default
minModuleSize <- 30
# Cut branches of dendrogram to ID WGCNA modules
dynamicMods <- cutreeDynamic(dendro =  geneTree,
distM = dissTOM,
deepSplit = 2,
pamRespectsDendro = FALSE,
minClusterSize = minModuleSize)
# Look at table of modules
table(dynamicMods)
# Convert module numbers into colors
dynamicColors <- labels2colors(dynamicMods)
# Plot dendrogram with module colors
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
dendroLabels = FALSE,
hang = 0.03,
addGuide = TRUE,
guideHang = 0.05,
main = "Gene dendrogram and module colors")
MElist <- moduleEigengenes(CrabExpr0, colors = dynamicColors)
# Save eigengenes as new object
MEs <- MElist$eigengenes
# Calculate dissimilarity of eigengenes
MEDiss <- 1-cor(MEs)
# Create cluster object
METree <- hclust(as.dist(MEDiss), method = "average")
# Plot dendrogram of clustered eigengenes
plot(METree, main = "Clustering of module eigengenes",
xlab = "",
sub = "")
# ID cut height based on sample number (3)
dynamicMergeCut(3)
plot(METree, main = "Clustering of module eigengenes",
xlab = "",
sub = "")
# ID cut height based on sample number (3)
dynamicMergeCut(3)
MEDissThres <- dynamicMergeCut(3)
plot(METree, main = "Clustering of module eigengenes",
xlab = "",
sub = "")
# ID cut height based on sample number (3)
dynamicMergeCut(3)
MEDissThres <- dynamicMergeCut(3)
abline(h = MEDissThres, col = "red")
merge <- mergeCloseModules(CrabExpr0, dynamicColors,
cutHeight = MEDissThres,
verbose = 3)
mergedColors <- merge$colors
mergedMEs <- merge$newMEs
# Plot dendrogram with original and merged eigengenes
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE,
hang = 0.03,
addGuide = TRUE,
guideHang = 0.05)
MEs <- mergedMEs # Replace unmerged MEs
moduleColors <- mergedColors
colorOrder <- c("grey", standardColors(50)) # Determine color order
moduleLabels <- match(moduleColors, colorOrder)-1 # Construct numerical labels based on colors
MEs <- mergedMEs # Replace unmerged MEs
nGenes <- ncol(CrabExpr0)
nSamples <- nrow(CrabExpr0)
# Recalculate MEs with color labels, order MEs based on MEs0
MEs0 <- moduleEigengenes(CrabExpr0, moduleColors)$eigengenes
MEs <- orderMEs(MEs0)
# Calculate trait correlations and obtain p-values
moduleTraitCor <- cor(MEs, crabTraits, use = "p")
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples)
# Create text matrix for correlations and their p-values
textMatrix <- paste(signif(moduleTraitCor, 2), "\n(",
signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix)
textMatrix
knitr::opts_chunk$set(echo = TRUE)
# Libraries we want to read in to our TPM matrix
libraries <- c("178", "118", "132", "359", "349", "334", "463", "481", "485")
# Path to kallisto libraries
kallisto_path <- "../output/kallisto_libraries/cbaihemat_transcriptomev2.0/"
# Libraries we want to read in to our TPM matrix
libraries <- c("178", "118", "132", "359", "349", "334", "463", "481", "485")
rep(c("A", "B", "C"), times = 3)
rep(17, times = 3))
crabTraits <- data.frame("crab" = rep(c("A", "B", "C"), times = 3),
"day" = c(rep(0, times = 3),
rep(2, times = 3),
rep(17, times = 3)))
View(crabTraits)
View(crabTraits)
# Create character vector with all filenames for our libraries
kallisto_files <- paste0(kallisto_path, "id", libraries, "/abundance.tsv")
# Read first kallisto file in to start data frame
TPMcounts <- read.delim(file = kallisto_files[1],
header = TRUE,
sep = "\t")
View(TPMcounts)
# Eliminate all columns except transcript ID and TPM
TPMcounts <- TPMcounts %>%
select(target_id, tpm)
# Rename columns for consistency and to ID TPM counts
colnames(TPMcounts)[1:2] <- c("Transcript_ID",
paste0(libraries[1], "_TPM"))
# Loop through remaining kallisto files, performing full joins to the kallisto file we read in
for (i in 2:length(kallisto_files)){
idnum <- str_extract(kallisto_files[i], "id[0-9]+")
kallisto_output <- read.delim(file = kallisto_files[i],
header = TRUE,
sep = "\t")
# Select only transcript ID and TPM (transcripts per million) columns
kallisto_output <- kallisto_output %>%
select(target_id, tpm)
# Rename kallisto column names to give ID to count column
colnames(kallisto_output)[1:2] <- c("Transcript_ID",
paste0(idnum, "_TPM"))
# Add TPM value to table of DEGs
# Perform full join, keeping all transcript IDs
TPMcounts <- full_join(TPMcounts, kallisto_output, by = "Transcript_ID")
}
View(TPMcounts)
# Move transcript ID to rownames
TPMcounts <- TPMcounts %>%
column_to_rownames(var = "Transcript_ID")
# Get initial dimensions of data frame
dim(TPMcounts)
# Filter out all variables with no counts greater than 10
TPMcounts <- TPMcounts %>%
filter_all(any_vars(. > 10))
# See how many transcripts we have left
dim(TPMcounts)
# Normalize raw counts with DESeq()
crab.dds <- DESeqDataSetFromMatrix(countData = TPMcounts,
colData = crabTraits,
design = ~day)
# Round all counts to the nearest integer
TPMcounts <- round(TPMcounts, digits = 0)
# Normalize raw counts with DESeq()
crab.dds <- DESeqDataSetFromMatrix(countData = TPMcounts,
colData = crabTraits,
design = ~day)
# For each row, crab and day should correspond to the order of libraries (ex: 4th row of crabTraits should match libraries[4])
crabTraits <- data.frame("crab" = rep(c("A", "B", "C"), times = 3),
"day" = factor(c(rep(0, times = 3),
rep(2, times = 3),
rep(17, times = 3))))
View(crabTraits)
# Normalize raw counts with DESeq()
crab.dds <- DESeqDataSetFromMatrix(countData = TPMcounts,
colData = crabTraits,
design = ~day)
View(crab.dds)
crab.dds <- DESeq(crab.dds)
# Perform vst on DESeq object
vsd <- getVarianceStabilizedData(crab.dds, blind = TRUE)
# Perform vst on DESeq object
vsd <- getVarianceStabilizedData(crab.dds)
View(vsd)
View(vsd)
dim(vsd)
# Transpose dataframe to format for WGCNA
CrabExpr0 <- as.data.frame(t(vsd))
# Check dataframe was transposed correctly
dim(CrabExpr0)
View(CrabExpr0)
gsg <- goodSamplesGenes(CrabExpr0, verbose = 3)
gsg$allOK      # should return TRUE if all genes pass test
sampleTree <- hclust(dist(CrabExpr0), method = "average")
plot(sampleTree)
# Print the crabTraits matrix we made earlier
head(crabTraits)
# Use same rownames as expression data to create analogous  matrix
rownames(crabTraits) <- rownames(CrabExpr0)
# Make sure it looks good
head(crabTraits)
View(TPMcounts)
# Path to kallisto libraries
kallisto_path <- "../output/kallisto_libraries/cbaihemat_transcriptomev2.0/"
# Libraries we want to read in to our TPM matrix
libraries <- c("178", "118", "132", "359", "349", "334", "463", "481", "485")
# For each row, crab and day should correspond to the order of libraries (ex: 4th row of crabTraits should match libraries[4])
crabTraits <- data.frame("crab" = rep(c("A", "B", "C"), times = 3),
"day" = factor(c(rep(0, times = 3),
rep(2, times = 3),
rep(17, times = 3))))
# Create character vector with all filenames for our libraries
kallisto_files <- paste0(kallisto_path, "id", libraries, "/abundance.tsv")
# Read first kallisto file in to start data frame
TPMcounts <- read.delim(file = kallisto_files[1],
header = TRUE,
sep = "\t")
# Eliminate all columns except transcript ID and TPM
TPMcounts <- TPMcounts %>%
select(target_id, tpm)
# Rename columns for consistency and to ID TPM counts
colnames(TPMcounts)[1:2] <- c("Transcript_ID",
paste0("id", libraries[1], "_TPM"))
# Loop through remaining kallisto files, performing full joins to the kallisto file we read in
for (i in 2:length(kallisto_files)){
idnum <- str_extract(kallisto_files[i], "id[0-9]+")
kallisto_output <- read.delim(file = kallisto_files[i],
header = TRUE,
sep = "\t")
# Select only transcript ID and TPM (transcripts per million) columns
kallisto_output <- kallisto_output %>%
select(target_id, tpm)
# Rename kallisto column names to give ID to count column
colnames(kallisto_output)[1:2] <- c("Transcript_ID",
paste0(idnum, "_TPM"))
# Add TPM value to table of DEGs
# Perform full join, keeping all transcript IDs
TPMcounts <- full_join(TPMcounts, kallisto_output, by = "Transcript_ID")
}
# Create logical matrix for whole dataframe, comparing values to 10
# Move transcript ID to rownames
TPMcounts <- TPMcounts %>%
column_to_rownames(var = "Transcript_ID")
# Get initial dimensions of data frame
dim(TPMcounts)
# Filter out all variables with no counts greater than 10
TPMcounts <- TPMcounts %>%
filter_all(any_vars(. > 10))
# See how many transcripts we have left
dim(TPMcounts)
# Round all counts to the nearest integer
TPMcounts <- round(TPMcounts, digits = 0)
# Normalize raw counts with DESeq()
crab.dds <- DESeqDataSetFromMatrix(countData = TPMcounts,
colData = crabTraits,
design = ~day)
crab.dds <- DESeq(crab.dds)
# Perform vst on DESeq object
vsd <- getVarianceStabilizedData(crab.dds)
# Transpose dataframe to format for WGCNA
CrabExpr0 <- as.data.frame(t(vsd))
# Check dataframe was transposed correctly
dim(CrabExpr0)
gsg <- goodSamplesGenes(CrabExpr0, verbose = 3)
gsg$allOK      # should return TRUE if all genes pass test
sampleTree <- hclust(dist(CrabExpr0), method = "average")
plot(sampleTree)
# Print the crabTraits matrix we made earlier
head(crabTraits)
# Use same rownames as expression data to create analogous  matrix
rownames(crabTraits) <- rownames(CrabExpr0)
# Make sure it looks good
head(crabTraits)
# Create a dendrogram to look at sample and trait clustering
sampleTree2 <- hclust(dist(CrabExpr0), method = "average")
# Convert traits to color values
traitColors <- numbers2colors(crabTraits, signed = FALSE)
as.numeric(crabTraits)
# Convert traits to color values
# First, change crabTraits day column to numeric
crabTraits$day <- as.numeric(crabTraits)
View(crabTraits)
crabTraits$day
as.numeric(crabTraits$day)
# Convert traits to color values
# First, change crabTraits day column to numeric
crabTraits <- data.frame(crabTraits$crab, as.numeric(crabTraits))
# Convert traits to color values
# First, change crabTraits day column to numeric
crabTraits$day <- as.numeric(as.character(crabTraits$day))
traitColors <- numbers2colors(crabTraits, signed = FALSE)
View(CrabExpr0)
View(crabTraits)
View(crabTraits)
# Create clinical data trait matrix. Same rules as above, but both crab and day are numeric. Crab A will be noted as 1, B as 2, and C as 3
crabClinicalData <- data.frame("crab" = rep(c(1, 2, 3), times = 3),
"day" = c(rep(0, times = 3),
rep(2, times = 3),
rep(17, times = 3)))
crabClinicalData
traitColors <- numbers2colors(crabClinicalData, signed = FALSE)
# Create a dendrogram to look at sample and trait clustering
sampleTree2 <- hclust(dist(CrabExpr0), method = "average")
traitColors <- numbers2colors(crabClinicalData, signed = FALSE)
# Plot dendrogram
plotDendroAndColors(sampleTree2, traitColors,
groupLabels = names(crabTraits))
# Create set of soft-thresholding powers
powers <- c(c(1:10), seq(from = 12, to = 20, by = 2))
# Use network topology analysis function to eval soft-thresholding power vals
sft <- pickSoftThreshold(CrabExpr0, powerVector = powers, verbose = 5)
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab = "Soft Threshold (power)",
ylab = "Scale Free Topology Model Fit, signed R^2",
type = "n",
main = paste("Scale independence"))
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab = "Soft Threshold (power)",
ylab = "Scale Free Topology Model Fit, signed R^2",
type = "n",
main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels = powers,
cex = 1,
col = "red")
abline(h = 0.90, col = "red")
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab = "Soft Threshold (power)",
ylab = "Scale Free Topology Model Fit, signed R^2",
type = "n",
main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels = powers,
cex = 1,
col = "red")
abline(h = 0.90, col = "red")
plot(sft$fitIndices[,1],sft$fitIndices[,5],
xlab = "Soft Threshold (power)",
ylab = "Mean Connectivity",
type = "n",
main = paste("Mean connectivity"))
# Add sft values
text(sft$fitIndices[,1], sft$fitIndices[,5],
labels = powers,
cex = 1,
col = "red")
?TOMsimilarity
softPower <- 9
adjacency <- adjacency(CrabExpr0, power = softPower)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(WGCNA)
library(DESeq2)
# Path to kallisto libraries
kallisto_path <- "../output/kallisto_libraries/cbaihemat_transcriptomev2.0/"
# Libraries we want to read in to our TPM matrix
libraries <- c("178", "118", "132", "359", "349", "334", "463", "481", "485")
# For each row, crab and day should correspond to the order of libraries (ex: 4th row of crabTraits should match libraries[4])
crabTraits <- data.frame("crab" = rep(c("A", "B", "C"), times = 3),
"day" = factor(c(rep(0, times = 3),
rep(2, times = 3),
rep(17, times = 3))))
# Create clinical data trait matrix. Same rules as above, but both crab and day are numeric. Crab A will be noted as 1, B as 2, and C as 3
crabClinicalData <- data.frame("crab" = rep(c(1, 2, 3), times = 3),
"day" = c(rep(0, times = 3),
rep(2, times = 3),
rep(17, times = 3)))
# Create character vector with all filenames for our libraries
kallisto_files <- paste0(kallisto_path, "id", libraries, "/abundance.tsv")
# Read first kallisto file in to start data frame
TPMcounts <- read.delim(file = kallisto_files[1],
header = TRUE,
sep = "\t")
# Eliminate all columns except transcript ID and TPM
TPMcounts <- TPMcounts %>%
select(target_id, tpm)
# Rename columns for consistency and to ID TPM counts
colnames(TPMcounts)[1:2] <- c("Transcript_ID",
paste0("id", libraries[1], "_TPM"))
# Loop through remaining kallisto files, performing full joins to the kallisto file we read in
for (i in 2:length(kallisto_files)){
idnum <- str_extract(kallisto_files[i], "id[0-9]+")
kallisto_output <- read.delim(file = kallisto_files[i],
header = TRUE,
sep = "\t")
# Select only transcript ID and TPM (transcripts per million) columns
kallisto_output <- kallisto_output %>%
select(target_id, tpm)
# Rename kallisto column names to give ID to count column
colnames(kallisto_output)[1:2] <- c("Transcript_ID",
paste0(idnum, "_TPM"))
# Add TPM value to table of DEGs
# Perform full join, keeping all transcript IDs
TPMcounts <- full_join(TPMcounts, kallisto_output, by = "Transcript_ID")
}
# Create logical matrix for whole dataframe, comparing values to 10
# Move transcript ID to rownames
TPMcounts <- TPMcounts %>%
column_to_rownames(var = "Transcript_ID")
# Get initial dimensions of data frame
dim(TPMcounts)
# Filter out all variables with no counts greater than 10
TPMcounts <- TPMcounts %>%
filter_all(any_vars(. > 10))
# See how many transcripts we have left
dim(TPMcounts)
# Round all counts to the nearest integer
TPMcounts <- round(TPMcounts, digits = 0)
# Normalize raw counts with DESeq()
crab.dds <- DESeqDataSetFromMatrix(countData = TPMcounts,
colData = crabTraits,
design = ~day)
crab.dds <- DESeq(crab.dds)
# Perform vst on DESeq object
vsd <- getVarianceStabilizedData(crab.dds)
# Transpose dataframe to format for WGCNA
CrabExpr0 <- as.data.frame(t(vsd))
# Check dataframe was transposed correctly
dim(CrabExpr0)
# Check for genes and samples with too many missing values
# This won't work here, because we only have 3 samples, and WGCNA requires more than 3, but hey - it's just a practice run. We'll therefore continue regardless, with this section commented out
gsg <- goodSamplesGenes(CrabExpr0, verbose = 3)
gsg$allOK      # should return TRUE if all genes pass test
sampleTree <- hclust(dist(CrabExpr0), method = "average")
plot(sampleTree)
# Print the crabTraits matrix we made earlier
head(crabTraits)
# Use same rownames as expression data to create analogous  matrix
rownames(crabTraits) <- rownames(CrabExpr0)
# Make sure it looks good
head(crabTraits)
# Create a dendrogram to look at sample and trait clustering
sampleTree2 <- hclust(dist(CrabExpr0), method = "average")
traitColors <- numbers2colors(crabClinicalData, signed = FALSE)
# Plot dendrogram
plotDendroAndColors(sampleTree2, traitColors,
groupLabels = names(crabTraits))
# Create set of soft-thresholding powers
powers <- c(c(1:10), seq(from = 12, to = 20, by = 2))
# Use network topology analysis function to eval soft-thresholding power vals
sft <- pickSoftThreshold(CrabExpr0, powerVector = powers, verbose = 5)
# Plot scale-free topology fit as function of soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab = "Soft Threshold (power)",
ylab = "Scale Free Topology Model Fit, signed R^2",
type = "n",
main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels = powers,
cex = 1,
col = "red")
# Plot mean connectivity as function of soft-thresholding power
plot(sft$fitIndices[,1],sft$fitIndices[,5],
xlab = "Soft Threshold (power)",
ylab = "Mean Connectivity",
type = "n",
main = paste("Mean connectivity"))
# Add sft values
text(sft$fitIndices[,1], sft$fitIndices[,5],
labels = powers,
cex = 1,
col = "red")
install.packages("grindr")
