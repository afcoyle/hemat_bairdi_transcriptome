# Rename first column
names(uniprot_info[1]) <- "accessionID"
View(uniprot_info)
# Rename first column
colnames(uniprot_info[1]) <- "accessionID"
View(uniprot_info)
colnames(uniprot_info[1])
# Rename first column
colnames(uniprot_info)[2] <- "accessionID"
View(uniprot_info)
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
uniprot_info <- read.table(file = "../data/all_uniprot_info_inc_GOterms.tab",
fill = TRUE, header = TRUE,
sep = '\t')
# Rename first column
colnames(uniprot_info)[1] <- "accessionID"
View(uniprot_info)
elev2_vs_amb02_GOterms <- left_join(elev2_vs_amb02_indiv_accessionIDs, uniprot_info, by = "accessionID")
View(elev2_vs_amb02_GOterms)
View(uniprot_info)
View(elev2_vs_amb02_GOterms)
View(elev2_vs_amb02_indiv_accessionIDs)
View(elev2_vs_amb02_indiv_accessionIDs)
# testing
filter(uniprot_info, accessionID == "O14931")
# Read in file of accession IDs from new analyses
elev2_vs_amb02_indiv_accessionIDs <- read.table(file = "../output/accession_n_GOids/allgenes_IDs/elev2_vs_amb02_indiv_only_All_GeneIDs.txt",
header = FALSE, col.names = "accessionID")
# Read in file of accession IDs from new analyses
elev2_vs_amb02_indiv_accessionIDs <- read.table(file = "../output/accession_n_GOids/allgenes_IDs/elev2_vs_amb02_indiv_only_All_GeneIDs.txt",
header = FALSE, col.names = "accessionID")
amb0217_elev0_low0_vs_elev2_accessionIDs <- read.table(file = "../output/accession_n_GOids/allgenes_IDs/amb0217_elev0_low0_vs_elev2_All_GeneIDs.txt",
header = FALSE, col.names = "accessionID")
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
uniprot_info <- read.table(file = "../data/all_uniprot_info_inc_GOterms.tab",
fill = TRUE, header = TRUE,
sep = '\t')
View(uniprot_info)
nrow(uniprot_info)
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
uniprot_info <- read.delim(file = "../data/all_uniprot_info_inc_GOterms.tab",
header = TRUE,
sep = '\t')
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
uniprot_info <- read.table(file = "../data/all_uniprot_info_inc_GOterms.tab",
header = TRUE,
sep = '\t')
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
uniprot_info <- read.delim(file = "../data/all_uniprot_info_inc_GOterms.tab",
header = TRUE,
sep = '\t')
nrow(uniprot_info)
View(uniprot_info)
# Rename first column
colnames(uniprot_info)[1] <- "accessionID"
elev2_vs_amb02_GOterms <- left_join(elev2_vs_amb02_indiv_accessionIDs, uniprot_info, by = "accessionID")
View(elev2_vs_amb02_GOterms)
# See our unmatched terms
elev2_vs_amb02_GOterms[is.na(elev2_vs_amb02_GOterms$Gene.ontology.IDs)]
# See our unmatched terms
elev2_vs_amb02_GOterms[is.na(elev2_vs_amb02_GOterms$Gene.ontology.IDs),]
# See how many unmatched terms we have
sum(is.na(elev2_vs_amb02_GOterms$Gene.ontology.IDs))
# Read in file of accession IDs from elev2_vs_amb02_indiv
accessionIDs <- read.table(file = "../output/accession_n_GOids/allgenes_IDs/elev2_vs_amb02_indiv_only_All_GeneIDs.txt",
header = FALSE, col.names = "accessionID")
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
uniprot_info <- read.delim(file = "../data/all_uniprot_info_inc_GOterms.tab",
header = TRUE,
sep = '\t')
# Rename first column
colnames(uniprot_info)[1] <- "accessionID"
Left join
#Left join
all_terms <- left_join(accessionIDs, uniprot_info, by = "accessionID")
# See how many unmatched terms we have
sum(is.na(all_terms$Gene.ontology.IDs))
# Select those unmatched terms, assign them to a new table
unmatched_terms <- all_terms[is.na(all_terms$Gene.ontology.IDs)]
# Select those unmatched terms, assign them to a new table
unmatched_terms <- all_terms[is.na(all_terms$Gene.ontology.IDs),]
View(unmatched_terms)
# Remove all unmatched terms from main table
all_terms <- all_terms[!is.na(all_terms$Gene.ontology.IDs),]
# Select only accession IDs and GO IDs
all_terms %>%
select(accessionID, Gene.ontology.IDs)
# Select only accession IDs and GO IDs
all_terms %>%
select(accessionID, Gene.ontology.IDs) %>%
head
# Select only accession IDs and GO IDs
GO_terms <- all_terms %>%
select(accessionID, Gene.ontology.IDs) %>%
head
# Select only accession IDs and GO IDs
GO_terms <- all_terms %>%
select(accessionID, Gene.ontology.IDs)
View(GO_terms)
View(all_terms)
View(GO_terms)
View(all_terms)
write.table(GO_terms, testing.txt, sep = "\t")
write.table(x = GO_terms, file = "testing.txt", sep = "\t")
write.table(x = GO_terms, file = "testing.txt", sep = "\t",
row.names = FALSE,
col.names = FALSE,
quote = FALSE)
# Specify filepath of output
outputpath <- "../output/accession_n_GOids/allgenes_IDs/elev2_vs_amb02_indiv_only_All_GOIDs.txt"
write.table(x = GO_terms, file = putputpath, sep = "\t",
row.names = FALSE,
col.names = FALSE,
quote = FALSE)
write.table(x = GO_terms, file = outputpath, sep = "\t",
row.names = FALSE,
col.names = FALSE,
quote = FALSE)
# Specify filepath of output
outputpath <- "../output/accession_n_GOids/allgenes_IDs/amb0217_elev0_low0_vs_elev2_All_GOIDs.txt"
# Read in file of accession IDs from elev2_vs_amb02_indiv
accessionIDs <- read.table(file = "../output/accession_n_GOids/amb0217_elev0_low0_vs_elev2_All_GeneIDs.txt",
header = FALSE, col.names = "accessionID")
# Read in file of accession IDs from elev2_vs_amb02_indiv
accessionIDs <- read.table(file = "../output/accession_n_GOids/allgenes_IDs/amb0217_elev0_low0_vs_elev2_All_GeneIDs.txt",
header = FALSE, col.names = "accessionID")
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
# When specifying data to download, select all GO terms
uniprot_info <- read.delim(file = "../data/all_uniprot_info_inc_GOterms.tab",
header = TRUE,
sep = '\t')
# Rename first column
colnames(uniprot_info)[1] <- "accessionID"
# Left join
all_terms <- left_join(accessionIDs, uniprot_info, by = "accessionID")
# See how many unmatched terms we have
sum(is.na(all_terms$Gene.ontology.IDs))
# Select those unmatched terms, assign them to a new table
unmatched_terms <- all_terms[is.na(all_terms$Gene.ontology.IDs),]
# Remove all unmatched terms from main table
all_terms <- all_terms[!is.na(all_terms$Gene.ontology.IDs),]
# Select only accession IDs and GO IDs in new table
GO_terms <- all_terms %>%
select(accessionID, Gene.ontology.IDs)
write.table(x = GO_terms, file = outputpath, sep = "\t",
row.names = FALSE,
col.names = FALSE,
quote = FALSE)
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
# When specifying data to download, select all GO terms
uniprot_info <- read.table(file = "../data/all_uniprot_info_inc_GOterms.tab",
fill = TRUE,
header = TRUE,
sep = '\t')
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
# When specifying data to download, select all GO terms
uniprot_info <- read.delim(file = "../data/all_uniprot_info_inc_GOterms.tab",
header = TRUE,
sep = '\t')
?read.delim
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
# When specifying data to download, select all GO terms
uniprot_info <- read.delim(file = "../data/all_uniprot_info_inc_GOterms.tab",
header = TRUE,
fill = TRUE,
sep = '\t')
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
# When specifying data to download, select all GO terms
uniprot_info <- read.table(file = "../data/all_uniprot_info_inc_GOterms.tab",
header = TRUE,
fill = TRUE,
sep = '\t')
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
# When specifying data to download, select all GO terms
uniprot_info <- read.table(file = "../data/all_uniprot_info_inc_GOterms.tab",
header = TRUE,
fill = TRUE,
sep = '\t',
quote = "\"",
dec = ".",
comment.char = "")
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
# When specifying data to download, select all GO terms
uniprot_info <- read.delim(file = "../data/all_uniprot_info_inc_GOterms.tab",
header = TRUE,
fill = TRUE,
sep = '\t',
quote = "\"",
dec = ".",
comment.char = "")
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
# When specifying data to download, select all GO terms
uniprot_info <- read.table(file = "../data/all_uniprot_info_inc_GOterms.tab",
header = TRUE,
fill = TRUE,
sep = '\t',
quote = "\"",
dec = ".",
comment.char = "")
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
# When specifying data to download, select all GO terms
uniprot_info <- read.table(file = "../data/all_uniprot_info_inc_GOterms.tab",
header = TRUE,
fill = TRUE,
sep = '\t',
quote = "\"",
dec = ".")
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
# When specifying data to download, select all GO terms
uniprot_info <- read.table(file = "../data/all_uniprot_info_inc_GOterms.tab",
header = TRUE,
fill = TRUE,
sep = '\t',
dec = ".",
comment.char = "")
# Read in uniprot data table downloaded from https://www.uniprot.org/uniprot/
# When specifying data to download, select all GO terms
uniprot_info <- read.delim(file = "../data/all_uniprot_info_inc_GOterms.tab",
header = TRUE,
fill = TRUE,
sep = '\t')
View(accessionIDs)
View(uniprot_info)
# Rename first column
colnames(uniprot_info)[1] <- "accessionID"
# Left join
all_terms <- left_join(accessionIDs, uniprot_info, by = "accessionID")
View(all_terms)
# See how many unmatched terms we have
sum(is.na(all_terms$Gene.ontology.IDs))
# Select those unmatched terms, assign them to a new table
unmatched_terms <- all_terms[is.na(all_terms$Gene.ontology.IDs),]
# Remove all unmatched terms from main table
all_terms <- all_terms[!is.na(all_terms$Gene.ontology.IDs),]
# Select only accession IDs and GO IDs in new table
GO_terms <- all_terms %>%
select(accessionID, Gene.ontology.IDs)
View(uniprot_info)
##########################################################
library(tidyverse)
# Functions are defined in hematodinium_analysis_functions.R
source("hematodinium_analysis_functions.R")
# Ambient and low-temp treatments
geneIDs_pvals(input_file = "../graphs/DESeq2_output/elev2_vs_amb02_indiv_only/AllGenes_wcols.txt",
blast_file = "../data/cbai_hemat_diamond_blastx_table_transcriptome_v2.0.txt",
output_file = "../scripts/06_running_GO-MWU/elev2_vs_amb02_indiv_only_pvals.csv")
# Elevated Day 2 vs. Ambient Day 0+2+17 + Elevated Day 0 + Lowered Day 0
geneIDs_pvals(input_file = "../graphs/DESeq2_output/amb0217_elev0_low0_vs_elev2/AllGenes_wcols.txt",
blast_file = "../data/cbai_hemat_diamond_blastx_table_transcriptome_v2.0.txt",
output_file = "../scripts/06_running_GO-MWU/amb0217_elev0_low0_vs_elev2_pvals.csv")
library(ape)
# Need to be in same directory as all other GO-MWU files -
# both data files and analysis files
setwd("06_running_GO-MWU")
# Edit these to match your data file names:
input="elev2_vs_amb02_indiv_only_pvals.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="elev2_vs_amb02_indiv_only_GOIDs_norepeats.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="C:/Users/acoyl/Documents/GradSchool/RobertsLab/Tools/perl/bin/perl.exe", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
windows()
results=gomwuPlot(input,goAnnotations,goDivision,
absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
#	absValue=1, # un-remark this if you are using log2-fold changes
level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
level2=0.05, # FDR cutoff to print in regular (not italic) font.
level3=0.01, # FDR cutoff to print in large bold font.
txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
treeHeight=0.5, # height of the hierarchical clustering tree
#	colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
)
# text representation of results, with actual adjusted p-values
results[[1]]
windows()
results=gomwuPlot(input,goAnnotations,goDivision,
absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
#	absValue=1, # un-remark this if you are using log2-fold changes
level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
level2=0.05, # FDR cutoff to print in regular (not italic) font.
level3=0.01, # FDR cutoff to print in large bold font.
txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
treeHeight=0.5, # height of the hierarchical clustering tree
#	colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
)
# text representation of results, with actual adjusted p-values
results[[1]]
pcut=1e-2 # adjusted pvalue cutoff for representative GO
hcut=0.9 # height at which cut the GO terms tree to get "independent groups".
# cutting
ct=cutree(results[[2]],h=hcut)
annots=c();ci=1
for (ci in unique(ct)) {
message(ci)
rn=names(ct)[ct==ci]
obs=grep("obsolete",rn)
if(length(obs)>0) { rn=rn[-obs] }
if (length(rn)==0) {next}
rr=results[[1]][rn,]
bestrr=rr[which(rr$pval==min(rr$pval)),]
best=1
if(nrow(bestrr)>1) {
nns=sub(" .+","",row.names(bestrr))
fr=c()
for (i in 1:length(nns)) { fr=c(fr,eval(parse(text=nns[i]))) }
best=which(fr==max(fr))
}
if (bestrr$pval[best]<=pcut) { annots=c(annots,sub("\\d+\\/\\d+ ","",row.names(bestrr)[best]))}
}
mwus=read.table(paste("MWU",goDivision,input,sep="_"),header=T)
bestGOs=mwus[mwus$name %in% annots,]
bestGOs
library(ape)
# Edit these to match your data file names:
input="amb0217_elev0_low0_vs_elev2_pvals.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="amb0217_elev0_low0_vs_elev2_GOIDs_norepeats.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="C:/Users/acoyl/Documents/GradSchool/RobertsLab/Tools/perl/bin/perl.exe", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
windows()
results=gomwuPlot(input,goAnnotations,goDivision,
absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
#	absValue=1, # un-remark this if you are using log2-fold changes
level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
level2=0.05, # FDR cutoff to print in regular (not italic) font.
level3=0.01, # FDR cutoff to print in large bold font.
txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
treeHeight=0.5, # height of the hierarchical clustering tree
#	colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
)
# text representation of results, with actual adjusted p-values
results[[1]]
windows()
results=gomwuPlot(input,goAnnotations,goDivision,
absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
#	absValue=1, # un-remark this if you are using log2-fold changes
level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
level2=0.05, # FDR cutoff to print in regular (not italic) font.
level3=0.01, # FDR cutoff to print in large bold font.
txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
treeHeight=0.5, # height of the hierarchical clustering tree
#	colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
)
# Edit these to match your data file names:
input="amb0217_elev0_low0_vs_elev2_pvals.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="amb0217_elev0_low0_vs_elev2_GOIDs_norepeats.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="C:/Users/acoyl/Documents/GradSchool/RobertsLab/Tools/perl/bin/perl.exe", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
windows()
results=gomwuPlot(input,goAnnotations,goDivision,
absValue=0.05,  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
#	absValue=1, # un-remark this if you are using log2-fold changes
level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
level2=0.05, # FDR cutoff to print in regular (not italic) font.
level3=0.01, # FDR cutoff to print in large bold font.
txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
treeHeight=0.5, # height of the hierarchical clustering tree
#	colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
)
# text representation of results, with actual adjusted p-values
results[[1]]
# Edit these to match your data file names:
input="elev2_vs_amb02_indiv_only_pvals.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="elev2_vs_amb02_indiv_only_GOIDs_norepeats.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="C:/Users/acoyl/Documents/GradSchool/RobertsLab/Tools/perl/bin/perl.exe", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
windows()
results=gomwuPlot(input,goAnnotations,goDivision,
absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
#	absValue=1, # un-remark this if you are using log2-fold changes
level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
level2=0.05, # FDR cutoff to print in regular (not italic) font.
level3=0.01, # FDR cutoff to print in large bold font.
txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
treeHeight=0.5, # height of the hierarchical clustering tree
#	colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
)
results=gomwuPlot(input,goAnnotations,goDivision,
absValue=0.05,  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
#	absValue=1, # un-remark this if you are using log2-fold changes
level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
level2=0.05, # FDR cutoff to print in regular (not italic) font.
level3=0.01, # FDR cutoff to print in large bold font.
txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
treeHeight=0.5, # height of the hierarchical clustering tree
#	colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
)
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="C:/Users/acoyl/Documents/GradSchool/RobertsLab/Tools/perl/bin/perl.exe", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
# Edit these to match your data file names:
input="amb0217_elev0_low0_vs_elev2_pvals.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="amb0217_elev0_low0_vs_elev2_GOIDs_norepeats.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="C:/Users/acoyl/Documents/GradSchool/RobertsLab/Tools/perl/bin/perl.exe", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
windows()
results=gomwuPlot(input,goAnnotations,goDivision,
absValue=0.05,  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
#	absValue=1, # un-remark this if you are using log2-fold changes
level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
level2=0.05, # FDR cutoff to print in regular (not italic) font.
level3=0.01, # FDR cutoff to print in large bold font.
txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
treeHeight=0.5, # height of the hierarchical clustering tree
#	colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
)
# Edit these to match your data file names:
input="elev2_vs_amb02_indiv_only_pvals.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="elev2_vs_amb02_indiv_only_GOIDs_norepeats.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="C:/Users/acoyl/Documents/GradSchool/RobertsLab/Tools/perl/bin/perl.exe", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
windows()
results=gomwuPlot(input,goAnnotations,goDivision,
absValue=0.05,  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
#	absValue=1, # un-remark this if you are using log2-fold changes
level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
level2=0.05, # FDR cutoff to print in regular (not italic) font.
level3=0.01, # FDR cutoff to print in large bold font.
txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
treeHeight=0.5, # height of the hierarchical clustering tree
#	colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
)
# text representation of results, with actual adjusted p-values
results[[1]]
pcut=1e-2 # adjusted pvalue cutoff for representative GO
hcut=0.9 # height at which cut the GO terms tree to get "independent groups".
# cutting
ct=cutree(results[[2]],h=hcut)
annots=c();ci=1
for (ci in unique(ct)) {
message(ci)
rn=names(ct)[ct==ci]
obs=grep("obsolete",rn)
if(length(obs)>0) { rn=rn[-obs] }
if (length(rn)==0) {next}
rr=results[[1]][rn,]
bestrr=rr[which(rr$pval==min(rr$pval)),]
best=1
if(nrow(bestrr)>1) {
nns=sub(" .+","",row.names(bestrr))
fr=c()
for (i in 1:length(nns)) { fr=c(fr,eval(parse(text=nns[i]))) }
best=which(fr==max(fr))
}
if (bestrr$pval[best]<=pcut) { annots=c(annots,sub("\\d+\\/\\d+ ","",row.names(bestrr)[best]))}
}
mwus=read.table(paste("MWU",goDivision,input,sep="_"),header=T)
bestGOs=mwus[mwus$name %in% annots,]
bestGOs
